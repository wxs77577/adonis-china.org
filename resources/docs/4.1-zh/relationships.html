<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_basic_example">Basic example</a></li>
<li><a href="#_has_one">Has One</a></li>
<li><a href="#_has_many">Has Many</a></li>
<li><a href="#_belongs_to">Belongs To</a></li>
<li><a href="#_belongs_to_many">Belongs To Many</a></li>
<li><a href="#_many_through">Many Through</a></li>
<li><a href="#_querying_data">Querying data</a></li>
<li><a href="#_eagerloading">EagerLoading</a></li>
<li><a href="#_lazy_eager_loading">Lazy eager loading</a></li>
<li><a href="#_filtering_data">Filtering data</a></li>
<li><a href="#_counts">Counts</a></li>
<li><a href="#_inserts_updates_deletes">Inserts, Updates &amp; Deletes</a></li>
</ul>
</div>
<div class="paragraph">
<p>Relationships are the backbone of data driven apps. Whether it is about maintaining <strong>posts</strong> written by a given <strong>author</strong> or <strong>cars</strong> from a given <strong>company</strong>.</p>
</div>
<div class="paragraph">
<p>Lucid expressive API makes the process of associating and fetching these relations so straightforward and intuitive, without even touching the SQL schema.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_example"><a class="anchor" href="#_basic_example"></a><a class="link" href="#_basic_example">Basic example</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Letâ€™s take the most common scenario of a User and a Profile model. Every user in your database can have a social profile. We call this a <strong>one to one relationship</strong>.</p>
</div>
<div class="sect2">
<h3 id="_defining_relationship"><a class="anchor" href="#_defining_relationship"></a><a class="link" href="#_defining_relationship">Defining relationship</a></h3>
<div class="paragraph">
<p>To describe this relationship, you have to add following lines of code to your User model.</p>
</div>
<div class="listingblock">
<div class="title">app/Models/User.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class User extends Model {
  profile () {
    return this.hasOne('App/Models/Profile')
  }
}

module.exports = User</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we create a method on the <code>User</code> model, which returns a <code>hasOne</code> relationship with the profile model. Also let&#8217;s create the <code>Profile</code> model too, to make this work.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is no need to define relationship on both the models. Defining it on a single model works as expected. Also, lucid relationships are not bound to SQL schema.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-bash" data-lang="bash">adonis make:model Profile</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">app/Models/Profile.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class Profile extends Model {
}

module.exports = Profile</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fetching_user_profile"><a class="anchor" href="#_fetching_user_profile"></a><a class="link" href="#_fetching_user_profile">Fetching user profile</a></h3>
<div class="paragraph">
<p>Execute the following code to fetch the user profile as per the defined relationship.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')

const user = await User.find(1)
const userProfile = await user.profile().fetch()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_has_one"><a class="anchor" href="#_has_one"></a><a class="link" href="#_has_one">Has One</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>hasOne</code> relationship defines a one to one relation using a <code>foreign key</code> to the other model.</p>
</div>
<div class="paragraph">
<p>Here is the list of parameters and you can override/define accordingly.</p>
</div>
<div class="sect2">
<h3 id="_api"><a class="anchor" href="#_api"></a><a class="link" href="#_api">API</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">hasOne(relatedModel, primaryKey, foreignKey)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">relateModel</dt>
<dd>
<p>Should always be defined as an Ioc container reference to the other Lucid model.</p>
</dd>
<dt class="hdlist1">primaryKey</dt>
<dd>
<p>Defaults to the current model primary key.</p>
</dd>
<dt class="hdlist1">foreignKey</dt>
<dd>
<p>Defaults to <code>tableName_primaryKey</code> of the current model. The singular form of the table name is used.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_database_tables"><a class="anchor" href="#_database_tables"></a><a class="link" href="#_database_tables">Database tables</a></h3>
<div class="paragraph">
<p><a href="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502900169/HasOne_wechyq.png" target="_blank" rel="noopener"><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502900169/HasOne_wechyq.png" alt="HasOne wechyq"></span></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_relation"><a class="anchor" href="#_defining_relation"></a><a class="link" href="#_defining_relation">Defining relation</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class User extends Model {
  profile () {
    return this.hasOne('App/Models/Profile')
  }
}

module.exports = User</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_has_many"><a class="anchor" href="#_has_many"></a><a class="link" href="#_has_many">Has Many</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>hasMany</code> relationship defines a one to many relationships using a <code>foreign key</code> to the other model.</p>
</div>
<div class="paragraph">
<p>Here is the list of parameters and you can override/define accordingly.</p>
</div>
<div class="sect2">
<h3 id="_api_2"><a class="anchor" href="#_api_2"></a><a class="link" href="#_api_2">API</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">hasMany(relatedModel, primaryKey, foreignKey)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">relateModel</dt>
<dd>
<p>Should always be defined as an Ioc container reference to the other Lucid model.</p>
</dd>
<dt class="hdlist1">primaryKey</dt>
<dd>
<p>Defaults to the current model primary key.</p>
</dd>
<dt class="hdlist1">foreignKey</dt>
<dd>
<p>Defaults to <code>tableName_primaryKey</code> of the current model. The singular form of the table name is used.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_database_tables_2"><a class="anchor" href="#_database_tables_2"></a><a class="link" href="#_database_tables_2">Database tables</a></h3>
<div class="paragraph">
<p><a href="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502900449/HasMany_kkbac9.png" target="_blank" rel="noopener"><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502900449/HasMany_kkbac9.png" alt="HasMany kkbac9"></span></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_relation_2"><a class="anchor" href="#_defining_relation_2"></a><a class="link" href="#_defining_relation_2">Defining relation</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class User extends Model {
  posts () {
    return this.hasMany('App/Models/Post')
  }
}

module.exports = User</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_belongs_to"><a class="anchor" href="#_belongs_to"></a><a class="link" href="#_belongs_to">Belongs To</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>belongsTo</code> relationship is similar to the <a href="#_has_one">hasOne</a> relationship, but instead, it is applied on the other end of the relation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s continue with the example of <strong>User</strong> and <strong>Profile</strong>; the profile model has the <code>belongsTo</code> relationship.</p>
</div>
<div class="sect2">
<h3 id="_api_3"><a class="anchor" href="#_api_3"></a><a class="link" href="#_api_3">API</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">belongsTo(relatedModel, primaryKey, foreignKey)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">relateModel</dt>
<dd>
<p>Should always be defined as an Ioc container reference to the other Lucid model.</p>
</dd>
<dt class="hdlist1">primaryKey</dt>
<dd>
<p>Defaults to the related model foreign key. Which is <code>user_id</code> in this case.</p>
</dd>
<dt class="hdlist1">foreignKey</dt>
<dd>
<p>Defaults to the related model primary key.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_database_tables_3"><a class="anchor" href="#_database_tables_3"></a><a class="link" href="#_database_tables_3">Database tables</a></h3>
<div class="paragraph">
<p><a href="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502900684/BelongsTo_fwqdc3.png" target="_blank" rel="noopener"><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502900684/BelongsTo_fwqdc3.png" alt="BelongsTo fwqdc3"></span></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_relation_3"><a class="anchor" href="#_defining_relation_3"></a><a class="link" href="#_defining_relation_3">Defining relation</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class Profile extends Model {
  user () {
    return this.belongsTo('App/Models/User')
  }
}

module.exports = Profile</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_belongs_to_many"><a class="anchor" href="#_belongs_to_many"></a><a class="link" href="#_belongs_to_many">Belongs To Many</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>belongsToMany</code> relationship is quite powerful since it allows you to define many to many relationships in both the models. For example</p>
</div>
<div class="olist ol-shrinked">
<ol class="ol-shrinked">
<li>
<p>A <strong>user</strong> can have many <strong>cars</strong>.</p>
</li>
<li>
<p>Also a <strong>car</strong> can have many <strong>owners</strong> during its life span.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When defining this relationship, there is no simple way to store a foreign key, and instead, we rely on a <code>3rd table</code>
called <strong>pivot table</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You have to create the <code>pivot_table</code> via migrations.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_api_4"><a class="anchor" href="#_api_4"></a><a class="link" href="#_api_4">API</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">belongsToMany(
  relatedModel,
  foreignKey,
  relatedForeignKey,
  primaryKey,
  relatedPrimaryKey
)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">relateModel</dt>
<dd>
<p>Should always be defined as an Ioc container reference to the other Lucid model.</p>
</dd>
<dt class="hdlist1">foreignKey</dt>
<dd>
<p>The foreign key for the current model, which is <code>user_id</code> in this case.</p>
</dd>
<dt class="hdlist1">relatedForeignKey</dt>
<dd>
<p>The foreign key for the related model, which is <code>car_id</code>.</p>
</dd>
<dt class="hdlist1">primaryKey</dt>
<dd>
<p>Current model primary key. This defaults to <code>id</code>.</p>
</dd>
<dt class="hdlist1">relatedPrimaryKey</dt>
<dd>
<p>Related model primary key. This defaults to <code>id</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_database_tables_4"><a class="anchor" href="#_database_tables_4"></a><a class="link" href="#_database_tables_4">Database Tables</a></h3>
<div class="paragraph">
<p><a href="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502903344/BelongsToMany_ngg7oj.png" target="_blank" rel="noopener"><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502903344/BelongsToMany_ngg7oj.png" alt="BelongsToMany ngg7oj"></span></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_relation_4"><a class="anchor" href="#_defining_relation_4"></a><a class="link" href="#_defining_relation_4">Defining relation</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class User extends Model {
  cars () {
    return this.belongsToMany('App/Models/Car')
  }
}

module.exports = User</code></pre>
</div>
</div>
<div class="paragraph">
<p>The table called <code>car_user</code> is the pivot table, which holds a unique relationship between the <strong>car</strong> and the <strong>user</strong>.</p>
</div>
<div class="sect3">
<h4 id="_pivottable"><a class="anchor" href="#_pivottable"></a><a class="link" href="#_pivottable">pivotTable</a></h4>
<div class="paragraph">
<p>You can also define a different table name by calling <code>pivotTable</code> method on the relationship.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">cars () {
  return this
    .belongsToMany('App/Models/Car')
    .pivotTable('user_cars')
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_withtimestamps"><a class="anchor" href="#_withtimestamps"></a><a class="link" href="#_withtimestamps">withTimestamps</a></h4>
<div class="paragraph">
<p>It is assumed that pivot table does not have timestamps. To enable timestamps, you must call <code>withTimestamps</code> table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">cars () {
  return this
    .belongsToMany('App/Models/Car')
    .withTimestamps()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_withpivot"><a class="anchor" href="#_withpivot"></a><a class="link" href="#_withpivot">withPivot</a></h4>
<div class="paragraph">
<p>When fetching the relationships, Lucid only selects the <code>foreign keys</code> from the pivot table. You can make it select other fields by calling <code>withPivot</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">cars () {
  return this
    .belongsToMany('App/Models/Car')
    .withPivot(['is_current_owner'])
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pivotmodel"><a class="anchor" href="#_pivotmodel"></a><a class="link" href="#_pivotmodel">pivotModel</a></h4>
<div class="paragraph">
<p>If you want more control over the queries made to the pivot table, you can bind a pivot model. With pivot model in place, you can use <strong>lifecycle hooks</strong>, <strong>define getters/setters</strong>, etc.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
After defining <code>pivotModel</code>, you cannot call <code>pivotTable</code> and <code>withTimestamps</code> methods. Instead, you are required to define these values on the pivot model.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">cars () {
  return this
    .belongsToMany('App/Models/Car')
    .pivotModel('App/Models/UserCar')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>UserCar</code> is a regular Lucid model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class UserCar extends Model {
  static boot () {
    super.boot()
    this.addHook('beforeCreate', (userCar) =&gt; {
      userCar.is_current_owner = true
    })
  }
}

module.exports = UserCar</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_many_through"><a class="anchor" href="#_many_through"></a><a class="link" href="#_many_through">Many Through</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The many through relationship is a convenient way to define an indirect relation. For example, A <strong>user</strong> belongs to a <strong>country</strong> and a <strong>user</strong> has many <strong>posts</strong>. Using many through, you can fetch all the <strong>posts</strong> for a given <strong>country</strong>.</p>
</div>
<div class="sect2">
<h3 id="_api_5"><a class="anchor" href="#_api_5"></a><a class="link" href="#_api_5">API</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">manyThrough(
  relatedModel,
  relatedMethod,
  primaryKey,
  foreignKey
)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">relateModel</dt>
<dd>
<p>Should always be defined as an Ioc container reference to the other Lucid model.</p>
</dd>
<dt class="hdlist1">relatedMethod</dt>
<dd>
<p>The relationship method to be called on the related model to fetch the through results.</p>
</dd>
<dt class="hdlist1">primaryKey</dt>
<dd>
<p>Current model primary key. This defaults to <code>id</code>.</p>
</dd>
<dt class="hdlist1">foreignKey</dt>
<dd>
<p>The foreign key for the current model, which is <code>country_id</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_database_tables_5"><a class="anchor" href="#_database_tables_5"></a><a class="link" href="#_database_tables_5">Database tables</a></h3>
<div class="paragraph">
<p><a href="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502905066/HasManyThrough_dcr86k.png" target="_blank" rel="noopener"><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/q_100/v1502905066/HasManyThrough_dcr86k.png" alt="HasManyThrough dcr86k"></span></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_relations"><a class="anchor" href="#_defining_relations"></a><a class="link" href="#_defining_relations">Defining relations</a></h3>
<div class="paragraph">
<p>The relationship needs to be defined on a couple of models. Let&#8217;s continue with the <strong>country posts</strong> concept and define required relationships.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class User extends Model {
  posts () {
    return this.hasMany('App/Models/Post')
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s define the many through relationship.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class Country extends Model {
  posts () {
    return this.manyThrough('App/Models/User', 'posts')
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>posts</code> parameter passed as the 2nd parameter is the reference to the <code>posts</code> method on the User model and is always required for a relationship to work.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_querying_data"><a class="anchor" href="#_querying_data"></a><a class="link" href="#_querying_data">Querying data</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Querying related data is pretty straight forward with the help of the intuitive API lucid offers. The API is consistent for all types of relationships.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s use the <strong>user</strong> and <strong>posts</strong> example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')

const user = await User.find(1)
const posts = await user.posts().fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above method fetches all the posts for the user with <code>id=1</code>.</p>
</div>
<div class="paragraph">
<p>You can also add runtime constraints by calling query builder methods as you would do with a normal query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)

// published posts
const posts = await user
  .posts()
  .where('is_published', true)
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fetch all posts that are published and belongs to the user with <code>id=1</code>.</p>
</div>
<div class="sect2">
<h3 id="_querying_pivot_table"><a class="anchor" href="#_querying_pivot_table"></a><a class="link" href="#_querying_pivot_table">Querying pivot table</a></h3>
<div class="paragraph">
<p>When working with a <code>belongsToMany</code> relationship, you can also add where clause on the pivot table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)

const cars = await user
  .cars()
  .wherePivot('is_current_owner', true)
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fetch all the cars, where the user with <code>id=1</code> is the current owner car of the car. Also, you can make use of <code>orWherePivot</code> and <code>whereInPivot</code> methods as well.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_eagerloading"><a class="anchor" href="#_eagerloading"></a><a class="link" href="#_eagerloading">EagerLoading</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Querying related data for a single entity is pretty simple, but when you want to fetch <strong>posts</strong> for more than one <strong>user</strong>, eager loading is something you should use.</p>
</div>
<div class="paragraph">
<p>Eager loading is a concept of fetching relationships with the minimum database queries possible. Let&#8217;s say if we do not use <strong>eager loading</strong> for a while and rely on the previous technique.</p>
</div>
<div class="listingblock">
<div class="title">Not recommended</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')

const users = await User.all()
const posts = []

for (let user of users) {
  const userPosts = await user.posts().fetch()
  posts.push(userPosts)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above is the worst thing you can do. Since it makes <strong>n+1</strong> queries to the database, where <strong>n</strong> is the number of users. Also, all of the queries are made in sequence ðŸ˜¨</p>
</div>
<div class="paragraph">
<p>On the other hand, eager loading makes a total of 2 database queries to fetch all the users and their related posts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')

const users = await User
  .query()
  .with('posts')
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>with</code> method loads the relationship as part of the original payload and running <code>users.toJSON()</code> returns a similar output as following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">[
  {
    id: 1,
    username: 'virk',
    posts: [{
      id: 1,
      user_id: 1,
      title: '...'
    }]
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also as you can see, the <code>posts</code> are defined as the user property, so it is easier to find which post belongs to which user.</p>
</div>
<div class="sect2">
<h3 id="_adding_runtime_constraints"><a class="anchor" href="#_adding_runtime_constraints"></a><a class="link" href="#_adding_runtime_constraints">Adding runtime constraints</a></h3>
<div class="paragraph">
<p>It is so simple to add runtime constraints to the relationship.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const users = await User
  .query()
  .with('posts', (builder) =&gt; {
    builder.where('is_published', true)
  })
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loading_multiple_relations"><a class="anchor" href="#_loading_multiple_relations"></a><a class="link" href="#_loading_multiple_relations">Loading multiple relations</a></h3>
<div class="paragraph">
<p>The multiple relations can be loaded by chaining the <code>with</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const users = await User
  .query()
  .with('posts')
  .with('profile')
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loading_nested_relations"><a class="anchor" href="#_loading_nested_relations"></a><a class="link" href="#_loading_nested_relations">Loading nested relations</a></h3>
<div class="paragraph">
<p>The nested relations are loaded with the help of <strong>dot notation(.)</strong> The following query loads all the <strong>posts</strong> with their related <strong>comments</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const users = await User
  .query()
  .with('posts.comments')
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Passing a callback to <code>with</code> for a nested relationship is applied to the last relation. For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const users = await User
  .query()
  .with('posts.comments', (builder) =&gt; {
    builder.where('approved', true)
  })
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above <code>where</code> clause is applied to the <code>comments</code> relationship and not to the <code>posts</code>.</p>
</div>
<div class="paragraph">
<p>To add a constraint to the first relationship, do something as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const users = await User
  .query()
  .with('posts', (builder) =&gt; {
    builder.where('is_published', true).with('comments')
  })
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we added a <code>where</code> clause to the <code>posts</code> relation and also eager loaded <code>comments</code> at the same time.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lazy_eager_loading"><a class="anchor" href="#_lazy_eager_loading"></a><a class="link" href="#_lazy_eager_loading">Lazy eager loading</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is also possible to eagerload relationships after fetching the first set of data. For example: Loading <code>posts</code> after fetching the user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)
await user.load('posts')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also you can lazily eagerload multiple relationships as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)
await user.loadMany(['posts', 'profiles'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to pass query constraints, you must pass an object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)
await user.loadMany({
  posts: (builder) =&gt; builder.where('is_published', true),
  profiles: null
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_filtering_data"><a class="anchor" href="#_filtering_data"></a><a class="link" href="#_filtering_data">Filtering data</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The enrich API of Lucid makes it so simple to filter data based upon the relationship. Let&#8217;s take a classic example of finding all those <strong>posts</strong> which has <strong>comments</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Model = use('Model')

class Post extends Model {
  comments () {
    return this.hasMany('App/Models/Comments')
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_has"><a class="anchor" href="#_has"></a><a class="link" href="#_has">has</a></h4>
<div class="paragraph">
<p>Now let&#8217;s add the filter to pull only those <code>posts</code> which has at least received one comment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .has('comments')
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>ðŸ˜² &nbsp; It is that simple! The <code>has</code> method makes sure only to get posts which have at least one comment.</p>
</div>
<div class="paragraph">
<p>Also, you can pass a count of how many comments should exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .has('comments', '&gt;', 2)
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wherehas"><a class="anchor" href="#_wherehas"></a><a class="link" href="#_wherehas">whereHas</a></h4>
<div class="paragraph">
<p>The <code>whereHas</code> is similar to <code>has</code> but instead you can add more constraints. For example: Fetch all <strong>posts</strong> which has at least 2 <strong>published comments</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .whereHas('comments', (builder) =&gt; {
    builder.where('is_published', true)
  }, '&gt;', 2)
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_doesnthave"><a class="anchor" href="#_doesnthave"></a><a class="link" href="#_doesnthave">doesntHave</a></h4>
<div class="paragraph">
<p>The opposite of <code>has</code> clause. This method does not accept a count expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .doesntHave('comments')
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wheredoesnthave"><a class="anchor" href="#_wheredoesnthave"></a><a class="link" href="#_wheredoesnthave">whereDoesntHave</a></h4>
<div class="paragraph">
<p>The opposite of <code>whereHas</code> clause. This method does not accept a count expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .whereDoesntHave('comments', (builder) =&gt; {
    builder.where('is_published', false)
  })
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also you can add <code>or</code> clause by calling <code>orHas</code>, <code>orWhereHas</code>, <code>orDoesntHave</code> and <code>orWhereDoesntHave</code> methods.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_counts"><a class="anchor" href="#_counts"></a><a class="link" href="#_counts">Counts</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Also, you can get counts of relationships by calling the <code>withCount</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .withCount('comments')
  .fetch()

posts.toJSON()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The json output will similar as following</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">{
  title: 'Adonis 101',
  __meta__: {
    comments_count: 2
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, define an alias for the count</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .withCount('comments as total_comments')
  .fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">__meta__: {
  total_comments: 2
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_adding_constraints"><a class="anchor" href="#_adding_constraints"></a><a class="link" href="#_adding_constraints">Adding constraints</a></h3>
<div class="paragraph">
<p>Let&#8217;s say you want to pull the count of comments which have been approved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const posts = await Post
  .query()
  .withCount('comments', (builder) =&gt; {
    builder.where('is_approved', true)
  })
  .fetch()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inserts_updates_deletes"><a class="anchor" href="#_inserts_updates_deletes"></a><a class="link" href="#_inserts_updates_deletes">Inserts, Updates &amp; Deletes</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Adding, updating and deleting related records is again as simple as querying data. Some of the <code>insertion</code> methods are specific to certain relationship types.</p>
</div>
<div class="sect3">
<h4 id="_save"><a class="anchor" href="#_save"></a><a class="link" href="#_save">save</a></h4>
<div class="paragraph">
<p>The <code>save</code> method expects an instance of the related model.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Works with</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>hasOne</p>
</li>
<li>
<p>hasMany</p>
</li>
<li>
<p>belongsToMany</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')
const Post = use('App/Models/Post')

const user = await User.find(1)

const post = new Post()
post.title = 'Adonis 101'

await user.posts().save(post)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_create"><a class="anchor" href="#_create"></a><a class="link" href="#_create">create</a></h4>
<div class="paragraph">
<p>The <code>create</code> is similar to the <code>save</code> method, but instead, accepts a normal javascript object and returns the related model instance.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Works with</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>hasOne</p>
</li>
<li>
<p>hasMany</p>
</li>
<li>
<p>belongsToMany</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')

const user = await User.find(1)

const post = await user
  .posts()
  .create({ title: 'Adonis 101' })</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_createmany"><a class="anchor" href="#_createmany"></a><a class="link" href="#_createmany">createMany</a></h4>
<div class="paragraph">
<p>Save many related rows to the database.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Works with</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>hasMany</p>
</li>
<li>
<p>belongsToMany</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')

const user = await User.find(1)

const post = await user
  .posts()
  .createMany([
    { title: 'Adonis 101' },
    { title: 'Lucid 101' }
  ])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_savemany"><a class="anchor" href="#_savemany"></a><a class="link" href="#_savemany">saveMany</a></h4>
<div class="paragraph">
<p>Same as <code>save</code> but instead saves multiple instances of the related model.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Works with</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>hasMany</p>
</li>
<li>
<p>belongsToMany</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')
const Post = use('App/Models/Post')

const user = await User.find(1)

const adonisPost = new Post()
adonisPost.title = 'Adonis 101'

const lucidPost = new Post()
lucidPost.title = 'Lucid 101'

await user
  .posts()
  .saveMany([adonisPost, lucidPost])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_associate"><a class="anchor" href="#_associate"></a><a class="link" href="#_associate">associate</a></h4>
<div class="paragraph">
<p>The <code>associate</code> method is exclusive to <code>belongsTo</code> relationship, where it associates two model instances together.</p>
</div>
<div class="paragraph">
<p>Continuing with the <strong>user</strong> and the <strong>profile</strong> example, let&#8217;s <code>associate</code> a user with a profile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Profile = use('App/Models/Profile')
const User = use('App/Models/User')

const user = await User.find(1)
const profile = await Profile.find(1)

await profile.user().associate(user)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dissociate"><a class="anchor" href="#_dissociate"></a><a class="link" href="#_dissociate">dissociate</a></h4>
<div class="paragraph">
<p>The <code>dissociate</code> method is the opposite of <code>associate</code>, where you just drop the relationship</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const Profile = use('App/Models/Profile')
const profile = await Profile.find(1)

await profile.user().dissociate()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_attach"><a class="anchor" href="#_attach"></a><a class="link" href="#_attach">attach</a></h4>
<div class="paragraph">
<p>The <code>attach</code> method works with the belongsToMany relationship to attach a relationship inside the <code>pivot</code> table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const User = use('App/Models/User')
const Car = use('App/Models/Car')

const mercedes = await Car.findBy('reg_no', '39020103')
const user = await User.find(1)

await user.cars().attach([mercedes.id])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>attach</code> method also accepts an optional callback, which receives the <code>pivotModel</code> instance, so that you can add extra attributes inside the pivot table if required.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>create</code> and <code>save</code> methods for <code>belongsToMany</code> also accepts the attach callback to add extra properties to the pivot table.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const mercedes = await Car.findBy('reg_no', '39020103')
const audi = await Car.findBy('reg_no', '99001020')

const user = await User.find(1)
const cars = [mercedes.id, audi.id]

await user.cars().attach(cars, (row) =&gt; {
  if (row.car_id === mercedes.id) {
    row.is_current_owner = true
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_detach"><a class="anchor" href="#_detach"></a><a class="link" href="#_detach">detach</a></h4>
<div class="paragraph">
<p>The <code>detach</code> method is the opposite of the <code>attach</code> method, and it removes the relationship from the pivot table only.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)
await user.cars().detach()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To detach selected cars, you need to pass an array of ids.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)
const mercedes = await Car.findBy('reg_no', '39020103')

await user.cars().detach([mercedes.id])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sync"><a class="anchor" href="#_sync"></a><a class="link" href="#_sync">sync</a></h4>
<div class="paragraph">
<p>The <code>sync</code> method is a shortcut for calling <code>detach</code> and then <code>attach</code> methods. It can be used for updating pivot table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const mercedes = await Car.findBy('reg_no', '39020103')
const user = await User.find(1)

// Behave the same way as:
// await user.cars().detach()
// await user.cars().attach([mercedes.id])

await user.cars().sync([mercedes.id])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_update"><a class="anchor" href="#_update"></a><a class="link" href="#_update">update</a></h4>
<div class="paragraph">
<p>The <code>update</code> method is used to make bulk updates on related rows. You can make use of the query builder methods to update specific fields only.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)

await user
  .posts()
  .where('title', 'Adonis 101')
  .update({ is_published: true })</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case of updating the pivot table, you can fetch the <code>query</code> instance for pivot table only.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)

await user
  .cars()
  .pivotQuery()
  .where('name', 'mercedes')
  .update({ is_current_owner: true })</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_delete"><a class="anchor" href="#_delete"></a><a class="link" href="#_delete">delete</a></h4>
<div class="paragraph">
<p>The <code>delete</code> method removes the related row from the database. In case of <code>belongsToMany</code>, this method also drops the relationship from <code>pivotTable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-js" data-lang="js">const user = await User.find(1)

await user
  .cars()
  .where('name', 'mercedes')
  .delete()</code></pre>
</div>
</div>
</div>
</div>
</div>